"""The KittyCAD Python SDK"""

import os
from typing import Any, Dict, List, Optional, Union
import httpx

{% if has_websockets %}
import json
import bson
from websockets.asyncio.client import (
    ClientConnection as ClientConnectionAsync,
    connect as ws_connect_async,
)
from websockets.sync.client import (
    ClientConnection as ClientConnectionSync,
    connect as ws_connect,
)
{% endif %}

from .client import AsyncClient, Client
from .pagination import AsyncPageIterator, SyncPageIterator
from .response_helpers import raise_for_status
from .exceptions import (
    KittyCADError,
    KittyCADAPIError,
    KittyCADClientError,
    KittyCADServerError,
    KittyCADConnectionError,
    KittyCADTimeoutError,
)

{% if has_websockets %}
# Import WebSocket-related models that may be referenced by endpoints
from .models.web_socket_request import WebSocketRequest
from .models.web_socket_response import WebSocketResponse
from .models.post_effect_type import PostEffectType
{% endif %}

{% for import in all_imports %}
{{ import }}
{% endfor %}

{% for tag, functions in endpoints_by_tag.items() %}
{% set tag_pascal = tag|to_pascal_case %}

class {{ tag_pascal }}API:
    """API for {{ tag }} endpoints"""
    
    def __init__(self, client: Client) -> None:
        self.client = client
    
    {% for func_name, func_info in functions.items() %}
    {% if func_info.is_websocket and func_info.has_websocket_class %}
    def {{ func_name }}(self{{ func_info.websocket_params if func_info.websocket_params else '' }}, recv_timeout: Optional[float] = None) -> "WebSocket{{ func_name|to_pascal_case }}":
        """{{ func_info.description }}
        
        Returns a WebSocket wrapper with methods for sending/receiving data.
        """
        return WebSocket{{ func_name|to_pascal_case }}({{ func_info.websocket_call_args if func_info.websocket_call_args else '' }}{{ ', ' if func_info.websocket_call_args else '' }}recv_timeout=recv_timeout, client=self.client)
    {% else %}
{{ func_info.sync_implementation }}
    {% endif %}
    {% endfor %}

class Async{{ tag_pascal }}API:
    """Async API for {{ tag }} endpoints"""
    
    def __init__(self, client: AsyncClient) -> None:
        self.client = client
    
    {% for func_name, func_info in functions.items() %}
    {% if func_info.is_websocket and func_info.has_websocket_class %}
    async def {{ func_name }}(self{{ func_info.websocket_params if func_info.websocket_params else '' }}):
        """{{ func_info.description }}
        
        Returns an async WebSocket connection for sending/receiving data.
        """
        # For async clients, return the raw async WebSocket connection
        # This supports await websocket.send() and async for message in websocket
        {{ func_info.async_implementation | replace("    ", "        ") | replace("\n", "\n        ") | trim }}
    {% else %}
{{ func_info.async_implementation }}
    {% endif %}
    {% endfor %}

{% endfor %}

{% for tag, functions in endpoints_by_tag.items() %}
{% for func_name, func_info in functions.items() %}
{% if func_info.is_websocket and func_info.has_websocket_class %}
class WebSocket{{ func_name|to_pascal_case }}:
    """A websocket connection for {{ func_name }}."""

    ws: ClientConnectionSync

    def __init__(self{{ func_info.websocket_params if func_info.websocket_params else '' }}, recv_timeout: Optional[float] = None, *, client: Client):
        # Inline WebSocket connection logic
        {% set path_args = func_info.ws_args|selectattr("in_url")|list %}
        url = ("{}" + "{{ func_info.path }}").format(client.base_url{% for arg in path_args %}, {{ arg.name }}={{ arg.name }}{% endfor %})
        {% for arg in func_info.ws_args %}
        {% if arg.in_query %}
        if {{ arg.name }} is not None:
            {% if "bool" in arg.type %}
            if "?" in url:
                url = url + "&{{ arg.name }}=" + str({{ arg.name }}).lower()
            else:
                url = url + "?{{ arg.name }}=" + str({{ arg.name }}).lower()
            {% else %}
            if "?" in url:
                url = url + "&{{ arg.name }}=" + str({{ arg.name }})
            else:
                url = url + "?{{ arg.name }}=" + str({{ arg.name }})
            {% endif %}
        {% endif %}
        {% endfor %}
        headers = client.get_headers()
        self.ws = ws_connect(url.replace("http", "ws"), additional_headers=headers, close_timeout=120, max_size=None)
        self._recv_timeout = (
            client.get_websocket_recv_timeout() if recv_timeout is None else recv_timeout
        )

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def __iter__(self):
        """
        Iterate on incoming messages.

        The iterator calls recv() and yields messages in an infinite loop.

        It exits when the connection is closed normally. It raises a
        ConnectionClosedError exception after a protocol error or a network failure.
        """
        for message in self.ws:
            {% if func_info.ws_response_is_dict %}
            yield json.loads(message)
            {% else %}
            yield {{ func_info.ws_response_type }}.model_validate_json(message)
            {% endif %}

    def send(self, data: {{ func_info.ws_request_type }}):
        """Send data to the websocket."""
        {% if func_info.ws_request_is_dict %}
        self.ws.send(json.dumps(data))
        {% else %}
        self.ws.send(json.dumps(data.model_dump()))
        {% endif %}

    def send_binary(self, data: {{ func_info.ws_request_type }}):
        """Send data as bson to the websocket."""
        {% if func_info.ws_request_is_dict %}
        self.ws.send(bson.encode(data))
        {% else %}
        self.ws.send(bson.encode(data.model_dump()))
        {% endif %}

    def recv(self) -> {{ func_info.ws_response_type }}:
        """Receive data from the websocket."""
        message = self.ws.recv(timeout=self._recv_timeout)
        {% if func_info.ws_response_is_dict %}
        return json.loads(message)
        {% else %}
        return {{ func_info.ws_response_type }}.model_validate_json(message)
        {% endif %}

    def close(self):
        """Close the websocket."""
        self.ws.close()

{% endif %}
{% endfor %}
{% endfor %}

class KittyCAD(Client):
    """Main KittyCAD client class with sync API interface.

    Usage:
        client = KittyCAD(token="your-api-token")
        user = client.users.get_user_self()

    Or with environment variable:
        client = KittyCAD()  # Uses KITTYCAD_API_TOKEN or ZOO_API_TOKEN

    Attributes:
        {% for tag in endpoints_by_tag.keys() %}
        {% set tag_pascal = tag|to_pascal_case %}
        {{ tag }}: {{ tag_pascal }}API - Access to {{ tag }} endpoints
        {% endfor %}
    """

    # API attribute type annotations for documentation
    {% for tag in endpoints_by_tag.keys() %}
    {% set tag_pascal = tag|to_pascal_case %}
    {{ tag }}: "{{ tag_pascal }}API"
    {% endfor %}

    def __init__(self, token: Optional[str] = None, **kwargs) -> None:
        if token is None:
            token = os.getenv("KITTYCAD_API_TOKEN") or os.getenv("ZOO_API_TOKEN")
            if token is None:
                raise ValueError(
                    "No API token provided. Either pass token parameter or set "
                    "KITTYCAD_API_TOKEN or ZOO_API_TOKEN environment variable."
                )
        
        # Also check for ZOO_HOST environment variable if no base_url provided
        if "base_url" not in kwargs:
            zoo_host = os.getenv("ZOO_HOST")
            if zoo_host:
                kwargs["base_url"] = zoo_host
        
        super().__init__(token=token, **kwargs)
        
        # Import and initialize API classes
        {% for tag in endpoints_by_tag.keys() %}
        {% set tag_pascal = tag|to_pascal_case %}
        self.{{ tag }}: {{ tag_pascal }}API = {{ tag_pascal }}API(self)
        {% endfor %}


class AsyncKittyCAD(AsyncClient):
    """Async KittyCAD client class with async API interface.

    Usage:
        import asyncio
        from kittycad import AsyncKittyCAD

        async def main():
            client = AsyncKittyCAD(token="your-api-token")
            user = await client.users.get_user_self()
            
        asyncio.run(main())

    Or with environment variable:
        client = AsyncKittyCAD()  # Uses KITTYCAD_API_TOKEN or ZOO_API_TOKEN

    Attributes:
        {% for tag in endpoints_by_tag.keys() %}
        {% set tag_pascal = tag|to_pascal_case %}
        {{ tag }}: Async{{ tag_pascal }}API - Access to {{ tag }} endpoints
        {% endfor %}
    """

    # API attribute type annotations for documentation
    {% for tag in endpoints_by_tag.keys() %}
    {% set tag_pascal = tag|to_pascal_case %}
    {{ tag }}: "Async{{ tag_pascal }}API"
    {% endfor %}

    def __init__(self, token: Optional[str] = None, **kwargs) -> None:
        if token is None:
            token = os.getenv("KITTYCAD_API_TOKEN") or os.getenv("ZOO_API_TOKEN")
            if token is None:
                raise ValueError(
                    "No API token provided. Either pass token parameter or set "
                    "KITTYCAD_API_TOKEN or ZOO_API_TOKEN environment variable."
                )
        
        # Also check for ZOO_HOST environment variable if no base_url provided
        if "base_url" not in kwargs:
            zoo_host = os.getenv("ZOO_HOST")
            if zoo_host:
                kwargs["base_url"] = zoo_host
        
        super().__init__(token=token, **kwargs)
        
        # Import and initialize async API classes
        {% for tag in endpoints_by_tag.keys() %}
        {% set tag_pascal = tag|to_pascal_case %}
        self.{{ tag }}: Async{{ tag_pascal }}API = Async{{ tag_pascal }}API(self)
        {% endfor %}


__all__ = [
    "KittyCAD",
    "AsyncKittyCAD",
    "KittyCADError",
    "KittyCADAPIError", 
    "KittyCADClientError",
    "KittyCADServerError",
    "KittyCADConnectionError",
    "KittyCADTimeoutError",
]

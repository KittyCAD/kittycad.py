"""The KittyCAD Python SDK - Generated Client Classes"""

import os
from typing import Any, Dict, Optional, Union, List
import httpx

{% if has_websockets %}
import json
import bson
from websockets.asyncio.client import (
    ClientConnection as ClientConnectionAsync,
    connect as ws_connect_async,
)
from websockets.sync.client import (
    ClientConnection as ClientConnectionSync,
    connect as ws_connect,
)
{% endif %}

from .client import Client
from .types import Response
from .response_helpers import raise_for_status
from .exceptions import (
    KittyCADError,
    KittyCADAPIError,
    KittyCADClientError,
    KittyCADServerError,
    KittyCADConnectionError,
    KittyCADTimeoutError,
)

# Import model types
{% for import_path in all_imports %}
{{ import_path }}
{% endfor %}

{% if has_websockets %}
# Import WebSocket request/response models
from .models.web_socket_request import WebSocketRequest
from .models.web_socket_response import WebSocketResponse
{% endif %}

{% for tag, functions in endpoints_by_tag.items() %}
{% set tag_pascal = tag|to_pascal_case %}
class {{ tag_pascal }}API:
    """API for {{ tag }} endpoints"""
    
    def __init__(self, client: Client) -> None:
        self.client = client
    
    {% for func_name, func_info in functions.items() %}
    {% if func_info.is_websocket and func_info.has_websocket_class %}
    def {{ func_name }}(self{{ func_info.parameters if func_info.parameters else '' }}) -> "WebSocket{{ func_name|to_pascal_case }}":
        """{{ func_info.description }}
        
        Returns a WebSocket wrapper with methods for sending/receiving data.
        """
        return WebSocket{{ func_name|to_pascal_case }}({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=self.client)
    {% elif func_info.is_websocket %}
    def {{ func_name }}(self{{ func_info.parameters if func_info.parameters else '' }}) -> ClientConnectionSync:
        """{{ func_info.description }}
        
        Returns a raw WebSocket connection for {{ func_name }}.
        """
        from .api.{{ tag }}.{{ func_name }} import sync
        return sync({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=self.client)
    {% else %}
    def {{ func_name }}(self{{ func_info.parameters if func_info.parameters else '' }}) -> {{ func_info.return_type }}:
        """{{ func_info.description }}"""
        from .api.{{ tag }}.{{ func_name }} import sync
        return sync({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=self.client)
    {% endif %}
    
    {% endfor %}


class Async{{ tag_pascal }}API:
    """Async API for {{ tag }} endpoints"""
    
    def __init__(self, client: Client) -> None:
        self.client = client
    
    {% for func_name, func_info in functions.items() %}
    {% if func_info.is_websocket and func_info.has_websocket_class %}
    def {{ func_name }}(self{{ func_info.parameters if func_info.parameters else '' }}) -> "WebSocket{{ func_name|to_pascal_case }}":
        """{{ func_info.description }}
        
        Returns a WebSocket wrapper with methods for sending/receiving data.
        Note: WebSocket connections are synchronous even in AsyncKittyCAD
        """
        return WebSocket{{ func_name|to_pascal_case }}({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=self.client)
    {% elif func_info.is_websocket %}
    async def {{ func_name }}(self{{ func_info.parameters if func_info.parameters else '' }}) -> ClientConnectionAsync:
        """{{ func_info.description }}
        
        Returns a raw async WebSocket connection for {{ func_name }}.
        """
        from .api.{{ tag }}.{{ func_name }} import asyncio
        return await asyncio({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=self.client)
    {% else %}
    async def {{ func_name }}(self{{ func_info.parameters if func_info.parameters else '' }}) -> {{ func_info.return_type }}:
        """{{ func_info.description }}"""
        from .api.{{ tag }}.{{ func_name }} import asyncio
        return await asyncio({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=self.client)
    {% endif %}
    
    {% endfor %}

{% endfor %}

{% for tag, functions in endpoints_by_tag.items() %}
{% for func_name, func_info in functions.items() %}
{% if func_info.is_websocket and func_info.has_websocket_class %}
class WebSocket{{ func_name|to_pascal_case }}:
    """A websocket connection for {{ func_name }}."""

    ws: ClientConnectionSync

    def __init__(self{{ func_info.parameters if func_info.parameters else '' }}, *, client: Client):
        from .api.{{ tag }}.{{ func_name }} import sync
        self.ws = sync({{ func_info.call_args if func_info.call_args else '' }}{{ ', ' if func_info.call_args else '' }}client=client)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        self.close()

    def __iter__(self):
        """
        Iterate on incoming messages.

        The iterator calls recv() and yields messages in an infinite loop.

        It exits when the connection is closed normally. It raises a
        ConnectionClosedError exception after a protocol error or a network failure.
        """
        for message in self.ws:
            yield WebSocketResponse(**json.loads(message))

    def send(self, data: WebSocketRequest):
        """Send data to the websocket."""
        self.ws.send(json.dumps(data.model_dump()))

    def send_binary(self, data: WebSocketRequest):
        """Send data as bson to the websocket."""
        self.ws.send(bson.encode(data.model_dump()))

    def recv(self) -> WebSocketResponse:
        """Receive data from the websocket."""
        message = self.ws.recv(timeout=60)
        return WebSocketResponse(**json.loads(message))

    def close(self):
        """Close the websocket."""
        self.ws.close()

{% endif %}
{% endfor %}
{% endfor %}

class KittyCAD(Client):
    """Main KittyCAD client class with sync API interface.

    Usage:
        client = KittyCAD(token="your-api-token")
        user = client.users.get_user_self()

    Or with environment variable:
        client = KittyCAD()  # Uses KITTYCAD_API_TOKEN or ZOO_API_TOKEN
    """

    def __init__(self, token: Optional[str] = None, **kwargs) -> None:
        if token is None:
            token = os.getenv("KITTYCAD_API_TOKEN") or os.getenv("ZOO_API_TOKEN")
            if token is None:
                raise ValueError(
                    "No API token provided. Either pass token parameter or set "
                    "KITTYCAD_API_TOKEN or ZOO_API_TOKEN environment variable."
                )
        
        # Also check for ZOO_HOST environment variable if no base_url provided
        if "base_url" not in kwargs:
            zoo_host = os.getenv("ZOO_HOST")
            if zoo_host:
                kwargs["base_url"] = zoo_host
        
        super().__init__(token=token, **kwargs)
        # Add API modules directly to client
        {% for tag in endpoints_by_tag.keys() %}
        {% set tag_pascal = tag|to_pascal_case %}
        self.{{ tag }}: {{ tag_pascal }}API = {{ tag_pascal }}API(self)
        {% endfor %}


class AsyncKittyCAD(Client):
    """Async KittyCAD client class with async API interface.

    Usage:
        import asyncio
        from kittycad import AsyncKittyCAD

        async def main():
            client = AsyncKittyCAD(token="your-api-token")
            user = await client.users.get_user_self()
            
        asyncio.run(main())

    Or with environment variable:
        client = AsyncKittyCAD()  # Uses KITTYCAD_API_TOKEN or ZOO_API_TOKEN
    """

    def __init__(self, token: Optional[str] = None, **kwargs) -> None:
        if token is None:
            token = os.getenv("KITTYCAD_API_TOKEN") or os.getenv("ZOO_API_TOKEN")
            if token is None:
                raise ValueError(
                    "No API token provided. Either pass token parameter or set "
                    "KITTYCAD_API_TOKEN or ZOO_API_TOKEN environment variable."
                )
        
        # Also check for ZOO_HOST environment variable if no base_url provided
        if "base_url" not in kwargs:
            zoo_host = os.getenv("ZOO_HOST")
            if zoo_host:
                kwargs["base_url"] = zoo_host
        
        super().__init__(token=token, **kwargs)
        # Add async API modules directly to client
        {% for tag in endpoints_by_tag.keys() %}
        {% set tag_pascal = tag|to_pascal_case %}
        self.{{ tag }}: Async{{ tag_pascal }}API = Async{{ tag_pascal }}API(self)
        {% endfor %}


__all__ = [
    "KittyCAD",
    "AsyncKittyCAD",
    "KittyCADError",
    "KittyCADAPIError", 
    "KittyCADClientError",
    "KittyCADServerError",
    "KittyCADConnectionError",
    "KittyCADTimeoutError",
]